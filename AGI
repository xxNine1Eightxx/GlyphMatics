ðŸŽ¼ Maestro â€” Full GGUF Hash + Sourcing + Network Graph
Boot â†’ install agent â†’ seed â†’ bind storage â†’ scan+hash .gguf â†’ source more â†’ chat
Boot & Weights
Bind Storage (choose GGUF parent)
Scan .gguf
Hash All (full SHA-256)
Download Seed PNG
Reinstall AGI
Self-Test
bootingâ€¦
Log
GGUF Registry
Updates & Stability
Refresh
stable: false
Source More Models
Add Another Folder
https://â€¦/manifest.json (GGUF-MANIFEST-1)
Fetch & Save
Model Network (Hub â†” Spokes)
`; function installAgentFromBytes(u8){ const html=b2t(u8); const iframe=document.createElement('iframe'); iframe.style.display='none'; document.body.appendChild(iframe); iframe.srcdoc=html; return new Promise((res,rej)=>{ let done=false; iframe.onload=()=>{ setTimeout(()=>{ done=true; (window.AGENTS && window.AGENTS['maestro-agi'])?res(true):rej(new Error('Agent not registered')); },60); }; setTimeout(()=>{ if(!done) rej(new Error('Installer timeout')); }, 5000); }); } /* ---------------- State ---------------- */ let seedBlobURL=null, storageBound=false, agentInstalled=false, weightsAligned=false; let rootHandles=[]; // multiple source folders let ggufIndex=[]; // {name, handle} let ggufRegistry=[]; // {name,size,sha256} const bootState=document.getElementById('bootState'); /* ---------------- Startup ---------------- */ async function boot(){ try{ bootState.textContent='bootingâ€¦'; println('Boot: initializing glyph engineâ€¦'); const updateGSM1=encodeBytesToGSM1(t2b(INSTALLER_HTML),{scale:'Cmaj16',bars:16}); await installAgentFromBytes(decodeGSM1(updateGSM1)); agentInstalled = !!(window.AGENTS && window.AGENTS['maestro-agi']); println('AGI installer â†’', agentInstalled?'OK':'missing'); try{ const blob=await buildSeedPNGFromCurrentHTML(); seedBlobURL=URL.createObjectURL(blob); const btn=document.getElementById('btnDownloadSeed'); btn.disabled=false; btn.onclick=()=>{ const a=document.createElement('a'); a.href=seedBlobURL; a.download='maestro_seed.png'; a.click(); }; println('Seed PNG ready. Download available.'); }catch(e){ println('Seed build error:', e.message); } bootState.textContent='awaiting weightsâ€¦'; }catch(e){ println('Boot error:', e.message); bootState.textContent='error'; }finally{ renderUpdates(); maybeUnlockChat(); drawGraph(); } } /* ---------------- Updates & gating ---------------- */ function isStable(){ return window.isSecureContext && ('showDirectoryPicker' in window) && storageBound && agentInstalled && !!seedBlobURL && weightsAligned; } function renderUpdates(){ const ul=document.getElementById('updatesList'); ul.innerHTML=''; const items=[ {label:'Secure context (HTTPS/localhost)', ok: window.isSecureContext}, {label:'File System Access API available', ok: ('showDirectoryPicker' in window)}, {label:'Storage bound (directory permission)', ok: storageBound}, {label:'AGI installed', ok: agentInstalled}, {label:'Seed PNG built', ok: !!seedBlobURL}, {label:'.gguf indexed', ok: ggufIndex.length>0}, {label:'Full hashes computed', ok: weightsAligned} ]; for(const it of items){ const li=document.createElement('li'); const l=document.createElement('div'); l.textContent=it.label; const r=document.createElement('div'); const s=document.createElement('span'); s.className='status ' + (it.ok?'ok':'bad'); s.textContent=it.ok?'OK':'NEEDED'; r.appendChild(s); li.appendChild(l); li.appendChild(r); ul.appendChild(li); } const st=isStable(); const badge=document.getElementById('stableBadge'); badge.textContent='stable: '+st; badge.style.background=st?'#14311f':'#3a1318'; badge.style.border=st?'1px solid #2b6f51':'1px solid #7b2b38'; } function maybeUnlockChat(){ const chatSec=document.getElementById('chatSec'); if (isStable()){ chatSec.classList.remove('hidden'); pushChat('system','Stable: agent, seed, storage, and full hashes are ready.'); } else { chatSec.classList.add('hidden'); } } /* ---------------- Bind / scan ---------------- */ const btnBind=document.getElementById('btnBind'), btnScan=document.getElementById('btnScan'), btnHashAll=document.getElementById('btnHashAll'); btnBind.onclick = async ()=>{ if (!('showDirectoryPicker' in window)){ println('FS Access API not available.'); return; } try{ const handle=await window.showDirectoryPicker({mode:'readwrite'}); rootHandles.push(handle); if (navigator.storage?.persist) await navigator.storage.persist(); // probe write const fh=await handle.getFileHandle('maestro.bind',{create:true}); const w=await fh.createWritable(); await w.write('ok'); await w.close(); storageBound=true; println('Storage bound âœ“ (folders: '+rootHandles.length+')'); btnScan.disabled=false; }catch(e){ println('Bind storage failed:', e.message); } renderUpdates(); maybeUnlockChat(); }; async function* walk(dirHandle, depth=3){ // search up to depth 3 for await (const [name,entry] of dirHandle.entries()){ if (entry.kind==='file'){ yield {name, handle: entry}; } else if (entry.kind==='directory' && depth>0){ for await (const x of walk(entry, depth-1)) yield {name: name+'/'+x.name, handle:x.handle}; } } } btnScan.onclick = async ()=>{ ggufIndex=[]; for (const h of rootHandles){ for await (const it of walk(h,3)){ if (it.name.toLowerCase().endsWith('.gguf')) ggufIndex.push(it); } } println('.gguf found:', ggufIndex.length); weightsEl.textContent=JSON.stringify({gguf_count: ggufIndex.length, names: ggufIndex.map(x=>x.name)}, null, 2); btnHashAll.disabled = ggufIndex.length===0; renderUpdates(); drawGraph(); }; /* ---------------- Full-file hashing ---------------- */ async function hashFile(handle, onProgress){ const file=await handle.getFile(); const size=file.size; const reader=file.stream().getReader(); const hasher=sha256(); let read=0; for(;;){ const {value, done}=await reader.read(); if (done) break; hasher.update(value); read+=value.length; if (onProgress) onProgress(read,size); } return {name: file.name, size, sha256: hasher.hex()}; } btnHashAll.onclick = async ()=>{ if (ggufIndex.length===0){ println('No .gguf to hash.'); return; } ggufRegistry=[]; weightsEl.textContent='Hashingâ€¦'; for (const it of ggufIndex){ const line = (msg)=> println(`[${it.name}] ${msg}`); line('start'); const res = await hashFile(it.handle, (r,s)=> line(`progress ${(r/s*100).toFixed(1)}%`)); line('done ' + res.sha256); ggufRegistry.push(res); drawGraph(); } weightsAligned = ggufRegistry.length>0; weightsEl.textContent = JSON.stringify({registry: ggufRegistry}, null, 2); renderUpdates(); maybeUnlockChat(); // Ask to source more if (confirm('Hashing complete. Do you want to source more models now?')){ document.getElementById('manifestUrl').focus(); } }; /* ---------------- Source more (folder or manifest) ---------------- */ document.getElementById('btnAddFolder').onclick = async ()=>{ await btnBind.onclick(); // reuse bind; adds another folder await btnScan.onclick(); // rescan with new folder }; document.getElementById('btnFetchManifest').onclick = async ()=>{ const url = (document.getElementById('manifestUrl').value||'').trim(); if (!url){ srcLog.textContent='Provide a manifest URL.'; return; } try{ const r=await fetch(url, {mode:'cors'}); const j=await r.json(); if (!j || j.version!=='GGUF-MANIFEST-1' || !Array.isArray(j.models)){ throw new Error('Bad manifest'); } srcLog.textContent='Manifest OK. Downloading '+j.models.length+' file(s)â€¦'; if (!rootHandles[0]){ srcLog.textContent+=' (Bind a folder first.)'; return; } const dst=rootHandles[0]; for (const m of j.models){ const resp=await fetch(m.url); const fh=await dst.getFileHandle(m.name, {create:true}); const w=await fh.createWritable(); if (resp.body){ const reader=resp.body.getReader(); for(;;){ const {value,done}=await reader.read(); if(done) break; await w.write(value); } }else{ await w.write(await resp.arrayBuffer()); } await w.close(); srcLog.textContent += `\nSaved ${m.name}`; } // rescan and rehash new ones await btnScan.onclick(); await btnHashAll.onclick(); }catch(e){ srcLog.textContent='Manifest fetch/save error: '+e.message+' (CORS or network may block).'; } }; /* ---------------- Graph (hub & spokes like your image) ---------------- */ const canvas=document.getElementById('graph'), ctx=canvas.getContext('2d'); function drawGraph(){ const W=canvas.width, H=canvas.height; ctx.clearRect(0,0,W,H); // background "grid" vibe ctx.fillStyle='#08122b'; ctx.fillRect(0,0,W,H); const cx=W/2, cy=H/2, R=Math.min(W,H)*0.36; // center hub ctx.fillStyle='#203b78'; ctx.strokeStyle='#6ea8ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,38,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#e6f0ff'; ctx.font='bold 14px ui-sans-serif'; ctx.textAlign='center'; ctx.fillText('Maestro', cx, cy+5); const N=Math.max(ggufRegistry.length, ggufIndex.length); const items = (ggufRegistry.length?ggufRegistry:ggufIndex).map((e,i)=>({ i, name: e.name||e, sha: e.sha256||null })); for (let k=0;k16?label.slice(0,15)+'â€¦':label, x, y+s+12); if (items[k].sha){ ctx.fillStyle='#8debd2'; ctx.fillText(items[k].sha.slice(0,10)+'â€¦', x, y+s+26); } } } /* ---------------- Chat ---------------- */ const chatlog=document.getElementById('chatlog'); const chat=[]; function pushChat(role,text){ chat.push({role,text,ts:new Date().toISOString()}); chatlog.textContent += `[${role}] ${text}\n`; chatlog.scrollTop=chatlog.scrollHeight; } document.getElementById('btnSend').onclick=async ()=>{ const q=document.getElementById('chatInput').value.trim(); if(!q) return; document.getElementById('chatInput').value=''; const agent=window.AGENTS?.['maestro-agi']; if (!agent){ pushChat('system','Agent not installed.'); return; } pushChat('user',q); const out=await agent.run(q); pushChat('assistant', out.final); }; document.getElementById('btnClear').onclick=()=>{ chat.length=0; chatlog.textContent=''; pushChat('system','Chat cleared.'); }; document.getElementById('btnExportChat').onclick=()=> saveBlob(t2b(JSON.stringify({chat},null,2)),'maestro_chat.json','application/json'); /* ---------------- Self-test & reinstall ---------------- */ document.getElementById('btnReinstall').onclick=async()=>{ await installAgentFromBytes(t2b(INSTALLER_HTML)); agentInstalled=true; println('AGI reinstalled.'); renderUpdates(); maybeUnlockChat(); }; document.getElementById('btnSelfTest').onclick=()=> println('Self-Test:', JSON.stringify({ secureContext: window.isSecureContext, fsAccess: 'showDirectoryPicker' in window, agent: !!(window.AGENTS && window.AGENTS['maestro-agi']), seeds: !!seedBlobURL, folders: rootHandles.length, ggufIndexed: ggufIndex.length, hashed: ggufRegistry.length }, null, 2)); document.getElementById('btnRefreshUpdates').onclick=()=>{ renderUpdates(); maybeUnlockChat(); }; /* ---------------- Download seed hookup ---------------- */ document.getElementById('btnDownloadSeed').disabled=true; /* ---------------- Kickoff ---------------- */ boot();
